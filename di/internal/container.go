// Code generated by DIGEN; DO NOT EDIT.
// This file was generated by Dependency Injection Container Generator  (built at ).
// See docs at https://github.com/strider2038/digen

package internal

import (
	"cmd/app/config"
	gathering_place_api "cmd/app/entities/gatheringPlace/api"
	gathering_place_repository "cmd/app/entities/gatheringPlace/repository"
	gathering_place_usecase "cmd/app/entities/gatheringPlace/usecases"
	meeting_api "cmd/app/entities/meeting/api"
	meeting_repository "cmd/app/entities/meeting/repository"
	meeting_usecase "cmd/app/entities/meeting/usecases"
	user_api "cmd/app/entities/user/api"
	user_repository "cmd/app/entities/user/repository"
	user_usecase "cmd/app/entities/user/usecases"
	"cmd/di/internal/factories"
	"cmd/di/internal/lookup"
	"context"
	"database/sql"
	chi "github.com/go-chi/chi/v5"
	"log"
	"net/http"
)

type Container struct {
	err error

	config config.Params
	logger *log.Logger
	db     *sql.DB
	server *http.Server
	router *chi.Mux

	api          *APIContainer
	useCases     *UseCaseContainer
	repositories *RepositoryContainer
}

func NewContainer() *Container {
	c := &Container{}
	c.api = &APIContainer{Container: c}
	c.useCases = &UseCaseContainer{Container: c}
	c.repositories = &RepositoryContainer{Container: c}

	return c
}

// Error returns the first initialization error, which can be set via SetError in a service definition.
func (c *Container) Error() error {
	return c.err
}

// SetError sets the first error into container. The error is used in the public container to return an initialization error.
func (c *Container) SetError(err error) {
	if err != nil && c.err == nil {
		c.err = err
	}
}

type APIContainer struct {
	*Container

	findMeetingHandler        *meeting_api.FindMeetingByIdHandler
	findUserHandler           *user_api.FindUserByIdHandler
	findGatheringPlaceHandler *gathering_place_api.FindGatheringPlaceByIdHandler
}

type UseCaseContainer struct {
	*Container

	findMeeting        *meeting_usecase.FindMeetingByIdUseCase
	findUser           *user_usecase.FindUserByIdUseCase
	findGatheringPlace *gathering_place_usecase.FindGatheringPlaceByIdUseCase
}

type RepositoryContainer struct {
	*Container

	meetingRepository        meeting_repository.MeetingsRepository
	userRepository           user_repository.UsersRepository
	gatheringPlaceRepository gathering_place_repository.PlacesRepository
}

func (c *Container) Config(ctx context.Context) config.Params {
	return c.config
}

func (c *Container) Logger(ctx context.Context) *log.Logger {
	if c.logger == nil && c.err == nil {
		c.logger = factories.CreateLogger(ctx, c)
	}
	return c.logger
}

func (c *Container) DB(ctx context.Context) *sql.DB {
	if c.db == nil && c.err == nil {
		c.db = factories.CreateDB(ctx, c)
	}
	return c.db
}

func (c *Container) Server(ctx context.Context) *http.Server {
	if c.server == nil && c.err == nil {
		c.server = factories.CreateServer(ctx, c)
	}
	return c.server
}

func (c *Container) Router(ctx context.Context) *chi.Mux {
	if c.router == nil && c.err == nil {
		c.router = factories.CreateRouter(ctx, c)
	}
	return c.router
}

func (c *Container) API() lookup.APIContainer {
	return c.api
}

func (c *APIContainer) FindMeetingHandler(ctx context.Context) *meeting_api.FindMeetingByIdHandler {
	if c.findMeetingHandler == nil && c.err == nil {
		c.findMeetingHandler = factories.CreateAPIFindMeetingHandler(ctx, c)
	}
	return c.findMeetingHandler
}

func (c *APIContainer) FindUserHandler(ctx context.Context) *user_api.FindUserByIdHandler {
	if c.findUserHandler == nil && c.err == nil {
		c.findUserHandler = factories.CreateAPIFindUserHandler(ctx, c)
	}
	return c.findUserHandler
}

func (c *APIContainer) FindGatheringPlaceHandler(ctx context.Context) *gathering_place_api.FindGatheringPlaceByIdHandler {
	if c.findGatheringPlaceHandler == nil && c.err == nil {
		c.findGatheringPlaceHandler = factories.CreateAPIFindGatheringPlaceHandler(ctx, c)
	}
	return c.findGatheringPlaceHandler
}

func (c *Container) UseCases() lookup.UseCaseContainer {
	return c.useCases
}

func (c *UseCaseContainer) FindMeeting(ctx context.Context) *meeting_usecase.FindMeetingByIdUseCase {
	if c.findMeeting == nil && c.err == nil {
		c.findMeeting = factories.CreateUseCasesFindMeeting(ctx, c)
	}
	return c.findMeeting
}

func (c *UseCaseContainer) FindUser(ctx context.Context) *user_usecase.FindUserByIdUseCase {
	if c.findUser == nil && c.err == nil {
		c.findUser = factories.CreateUseCasesFindUser(ctx, c)
	}
	return c.findUser
}

func (c *UseCaseContainer) FindGatheringPlace(ctx context.Context) *gathering_place_usecase.FindGatheringPlaceByIdUseCase {
	if c.findGatheringPlace == nil && c.err == nil {
		c.findGatheringPlace = factories.CreateUseCasesFindGatheringPlace(ctx, c)
	}
	return c.findGatheringPlace
}

func (c *Container) Repositories() lookup.RepositoryContainer {
	return c.repositories
}

func (c *RepositoryContainer) MeetingRepository(ctx context.Context) meeting_repository.MeetingsRepository {
	if c.meetingRepository == nil && c.err == nil {
		c.meetingRepository = factories.CreateRepositoriesMeetingRepository(ctx, c)
	}
	return c.meetingRepository
}

func (c *RepositoryContainer) UserRepository(ctx context.Context) user_repository.UsersRepository {
	if c.userRepository == nil && c.err == nil {
		c.userRepository = factories.CreateRepositoriesUserRepository(ctx, c)
	}
	return c.userRepository
}

func (c *RepositoryContainer) GatheringPlaceRepository(ctx context.Context) gathering_place_repository.PlacesRepository {
	if c.gatheringPlaceRepository == nil && c.err == nil {
		c.gatheringPlaceRepository = factories.CreateRepositoriesGatheringPlaceRepository(ctx, c)
	}
	return c.gatheringPlaceRepository
}

func (c *Container) SetConfig(s config.Params) {
	c.config = s
}

func (c *RepositoryContainer) SetMeetingRepository(s meeting_repository.MeetingsRepository) {
	c.meetingRepository = s
}

func (c *RepositoryContainer) SetUserRepository(s user_repository.UsersRepository) {
	c.userRepository = s
}

func (c *RepositoryContainer) SetGatheringPlaceRepository(s gathering_place_repository.PlacesRepository) {
	c.gatheringPlaceRepository = s
}

func (c *Container) Close() {
	if c.db != nil {
		c.db.Close()
	}

	if c.server != nil {
		c.server.Close()
	}
}
